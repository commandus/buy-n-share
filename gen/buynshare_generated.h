// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BUYNSHARE_BS_H_
#define FLATBUFFERS_GENERATED_BUYNSHARE_BS_H_

#include "flatbuffers/flatbuffers.h"

namespace bs {

struct Geo;

struct User;

struct Fridge;

struct Meal;

struct Purchase;

struct MealCard;

struct FridgeMealCards;

struct FridgeUser;

struct FridgeUsers;

struct UserPurchases;

struct FridgePurchases;

struct UserFridges;

struct Users;

struct Fridges;

struct Purchases;

struct Meals;

struct MealCards;

struct Payment;

struct Payments;

MANUALLY_ALIGNED_STRUCT(4) Geo FLATBUFFERS_FINAL_CLASS {
 private:
  float lat_;
  float lon_;
  int32_t alt_;

 public:
  Geo() {
    memset(this, 0, sizeof(Geo));
  }
  Geo(const Geo &_o) {
    memcpy(this, &_o, sizeof(Geo));
  }
  Geo(float _lat, float _lon, int32_t _alt)
      : lat_(flatbuffers::EndianScalar(_lat)),
        lon_(flatbuffers::EndianScalar(_lon)),
        alt_(flatbuffers::EndianScalar(_alt)) {
  }
  float lat() const {
    return flatbuffers::EndianScalar(lat_);
  }
  float lon() const {
    return flatbuffers::EndianScalar(lon_);
  }
  int32_t alt() const {
    return flatbuffers::EndianScalar(alt_);
  }
};
STRUCT_END(Geo, 12);

struct User FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_CN = 6,
    VT_KEY = 8,
    VT_LOCALE = 10,
    VT_GEO = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const flatbuffers::String *cn() const {
    return GetPointer<const flatbuffers::String *>(VT_CN);
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *locale() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALE);
  }
  const Geo *geo() const {
    return GetStruct<const Geo *>(VT_GEO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_CN) &&
           verifier.Verify(cn()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyOffset(verifier, VT_LOCALE) &&
           verifier.Verify(locale()) &&
           VerifyField<Geo>(verifier, VT_GEO) &&
           verifier.EndTable();
  }
};

struct UserBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(User::VT_ID, id, 0);
  }
  void add_cn(flatbuffers::Offset<flatbuffers::String> cn) {
    fbb_.AddOffset(User::VT_CN, cn);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(User::VT_KEY, key);
  }
  void add_locale(flatbuffers::Offset<flatbuffers::String> locale) {
    fbb_.AddOffset(User::VT_LOCALE, locale);
  }
  void add_geo(const Geo *geo) {
    fbb_.AddStruct(User::VT_GEO, geo);
  }
  UserBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserBuilder &operator=(const UserBuilder &);
  flatbuffers::Offset<User> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<User>(end);
    return o;
  }
};

inline flatbuffers::Offset<User> CreateUser(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    flatbuffers::Offset<flatbuffers::String> cn = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> locale = 0,
    const Geo *geo = 0) {
  UserBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_geo(geo);
  builder_.add_locale(locale);
  builder_.add_key(key);
  builder_.add_cn(cn);
  return builder_.Finish();
}

inline flatbuffers::Offset<User> CreateUserDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *cn = nullptr,
    const char *key = nullptr,
    const char *locale = nullptr,
    const Geo *geo = 0) {
  return bs::CreateUser(
      _fbb,
      id,
      cn ? _fbb.CreateString(cn) : 0,
      key ? _fbb.CreateString(key) : 0,
      locale ? _fbb.CreateString(locale) : 0,
      geo);
}

struct Fridge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_CN = 6,
    VT_KEY = 8,
    VT_LOCALE = 10,
    VT_GEO = 12
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const flatbuffers::String *cn() const {
    return GetPointer<const flatbuffers::String *>(VT_CN);
  }
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *locale() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALE);
  }
  const Geo *geo() const {
    return GetStruct<const Geo *>(VT_GEO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_CN) &&
           verifier.Verify(cn()) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyOffset(verifier, VT_LOCALE) &&
           verifier.Verify(locale()) &&
           VerifyField<Geo>(verifier, VT_GEO) &&
           verifier.EndTable();
  }
};

struct FridgeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Fridge::VT_ID, id, 0);
  }
  void add_cn(flatbuffers::Offset<flatbuffers::String> cn) {
    fbb_.AddOffset(Fridge::VT_CN, cn);
  }
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Fridge::VT_KEY, key);
  }
  void add_locale(flatbuffers::Offset<flatbuffers::String> locale) {
    fbb_.AddOffset(Fridge::VT_LOCALE, locale);
  }
  void add_geo(const Geo *geo) {
    fbb_.AddStruct(Fridge::VT_GEO, geo);
  }
  FridgeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FridgeBuilder &operator=(const FridgeBuilder &);
  flatbuffers::Offset<Fridge> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<Fridge>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fridge> CreateFridge(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    flatbuffers::Offset<flatbuffers::String> cn = 0,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> locale = 0,
    const Geo *geo = 0) {
  FridgeBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_geo(geo);
  builder_.add_locale(locale);
  builder_.add_key(key);
  builder_.add_cn(cn);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fridge> CreateFridgeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *cn = nullptr,
    const char *key = nullptr,
    const char *locale = nullptr,
    const Geo *geo = 0) {
  return bs::CreateFridge(
      _fbb,
      id,
      cn ? _fbb.CreateString(cn) : 0,
      key ? _fbb.CreateString(key) : 0,
      locale ? _fbb.CreateString(locale) : 0,
      geo);
}

struct Meal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_CN = 6,
    VT_LOCALE = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const flatbuffers::String *cn() const {
    return GetPointer<const flatbuffers::String *>(VT_CN);
  }
  const flatbuffers::String *locale() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_CN) &&
           verifier.Verify(cn()) &&
           VerifyOffset(verifier, VT_LOCALE) &&
           verifier.Verify(locale()) &&
           verifier.EndTable();
  }
};

struct MealBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Meal::VT_ID, id, 0);
  }
  void add_cn(flatbuffers::Offset<flatbuffers::String> cn) {
    fbb_.AddOffset(Meal::VT_CN, cn);
  }
  void add_locale(flatbuffers::Offset<flatbuffers::String> locale) {
    fbb_.AddOffset(Meal::VT_LOCALE, locale);
  }
  MealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MealBuilder &operator=(const MealBuilder &);
  flatbuffers::Offset<Meal> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Meal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Meal> CreateMeal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    flatbuffers::Offset<flatbuffers::String> cn = 0,
    flatbuffers::Offset<flatbuffers::String> locale = 0) {
  MealBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_locale(locale);
  builder_.add_cn(cn);
  return builder_.Finish();
}

inline flatbuffers::Offset<Meal> CreateMealDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const char *cn = nullptr,
    const char *locale = nullptr) {
  return bs::CreateMeal(
      _fbb,
      id,
      cn ? _fbb.CreateString(cn) : 0,
      locale ? _fbb.CreateString(locale) : 0);
}

struct Purchase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_USERID = 6,
    VT_FRIDGEID = 8,
    VT_MEAL = 10,
    VT_COST = 12,
    VT_START = 14,
    VT_FINISH = 16,
    VT_VOTES = 18
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  uint64_t userid() const {
    return GetField<uint64_t>(VT_USERID, 0);
  }
  uint64_t fridgeid() const {
    return GetField<uint64_t>(VT_FRIDGEID, 0);
  }
  const Meal *meal() const {
    return GetPointer<const Meal *>(VT_MEAL);
  }
  uint32_t cost() const {
    return GetField<uint32_t>(VT_COST, 0);
  }
  uint32_t start() const {
    return GetField<uint32_t>(VT_START, 0);
  }
  uint32_t finish() const {
    return GetField<uint32_t>(VT_FINISH, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<User>> *votes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<User>> *>(VT_VOTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<uint64_t>(verifier, VT_USERID) &&
           VerifyField<uint64_t>(verifier, VT_FRIDGEID) &&
           VerifyOffset(verifier, VT_MEAL) &&
           verifier.VerifyTable(meal()) &&
           VerifyField<uint32_t>(verifier, VT_COST) &&
           VerifyField<uint32_t>(verifier, VT_START) &&
           VerifyField<uint32_t>(verifier, VT_FINISH) &&
           VerifyOffset(verifier, VT_VOTES) &&
           verifier.Verify(votes()) &&
           verifier.VerifyVectorOfTables(votes()) &&
           verifier.EndTable();
  }
};

struct PurchaseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Purchase::VT_ID, id, 0);
  }
  void add_userid(uint64_t userid) {
    fbb_.AddElement<uint64_t>(Purchase::VT_USERID, userid, 0);
  }
  void add_fridgeid(uint64_t fridgeid) {
    fbb_.AddElement<uint64_t>(Purchase::VT_FRIDGEID, fridgeid, 0);
  }
  void add_meal(flatbuffers::Offset<Meal> meal) {
    fbb_.AddOffset(Purchase::VT_MEAL, meal);
  }
  void add_cost(uint32_t cost) {
    fbb_.AddElement<uint32_t>(Purchase::VT_COST, cost, 0);
  }
  void add_start(uint32_t start) {
    fbb_.AddElement<uint32_t>(Purchase::VT_START, start, 0);
  }
  void add_finish(uint32_t finish) {
    fbb_.AddElement<uint32_t>(Purchase::VT_FINISH, finish, 0);
  }
  void add_votes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<User>>> votes) {
    fbb_.AddOffset(Purchase::VT_VOTES, votes);
  }
  PurchaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PurchaseBuilder &operator=(const PurchaseBuilder &);
  flatbuffers::Offset<Purchase> Finish() {
    const auto end = fbb_.EndTable(start_, 8);
    auto o = flatbuffers::Offset<Purchase>(end);
    return o;
  }
};

inline flatbuffers::Offset<Purchase> CreatePurchase(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint64_t userid = 0,
    uint64_t fridgeid = 0,
    flatbuffers::Offset<Meal> meal = 0,
    uint32_t cost = 0,
    uint32_t start = 0,
    uint32_t finish = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<User>>> votes = 0) {
  PurchaseBuilder builder_(_fbb);
  builder_.add_fridgeid(fridgeid);
  builder_.add_userid(userid);
  builder_.add_id(id);
  builder_.add_votes(votes);
  builder_.add_finish(finish);
  builder_.add_start(start);
  builder_.add_cost(cost);
  builder_.add_meal(meal);
  return builder_.Finish();
}

inline flatbuffers::Offset<Purchase> CreatePurchaseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint64_t userid = 0,
    uint64_t fridgeid = 0,
    flatbuffers::Offset<Meal> meal = 0,
    uint32_t cost = 0,
    uint32_t start = 0,
    uint32_t finish = 0,
    const std::vector<flatbuffers::Offset<User>> *votes = nullptr) {
  return bs::CreatePurchase(
      _fbb,
      id,
      userid,
      fridgeid,
      meal,
      cost,
      start,
      finish,
      votes ? _fbb.CreateVector<flatbuffers::Offset<User>>(*votes) : 0);
}

struct MealCard FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MEAL = 4,
    VT_QTY = 6
  };
  const Meal *meal() const {
    return GetPointer<const Meal *>(VT_MEAL);
  }
  uint8_t qty() const {
    return GetField<uint8_t>(VT_QTY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEAL) &&
           verifier.VerifyTable(meal()) &&
           VerifyField<uint8_t>(verifier, VT_QTY) &&
           verifier.EndTable();
  }
};

struct MealCardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meal(flatbuffers::Offset<Meal> meal) {
    fbb_.AddOffset(MealCard::VT_MEAL, meal);
  }
  void add_qty(uint8_t qty) {
    fbb_.AddElement<uint8_t>(MealCard::VT_QTY, qty, 0);
  }
  MealCardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MealCardBuilder &operator=(const MealCardBuilder &);
  flatbuffers::Offset<MealCard> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<MealCard>(end);
    return o;
  }
};

inline flatbuffers::Offset<MealCard> CreateMealCard(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Meal> meal = 0,
    uint8_t qty = 0) {
  MealCardBuilder builder_(_fbb);
  builder_.add_meal(meal);
  builder_.add_qty(qty);
  return builder_.Finish();
}

struct FridgeMealCards FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRIDGE = 4,
    VT_MEALCARDS = 6
  };
  const Fridge *fridge() const {
    return GetPointer<const Fridge *>(VT_FRIDGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MealCard>> *mealcards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MealCard>> *>(VT_MEALCARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FRIDGE) &&
           verifier.VerifyTable(fridge()) &&
           VerifyOffset(verifier, VT_MEALCARDS) &&
           verifier.Verify(mealcards()) &&
           verifier.VerifyVectorOfTables(mealcards()) &&
           verifier.EndTable();
  }
};

struct FridgeMealCardsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fridge(flatbuffers::Offset<Fridge> fridge) {
    fbb_.AddOffset(FridgeMealCards::VT_FRIDGE, fridge);
  }
  void add_mealcards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MealCard>>> mealcards) {
    fbb_.AddOffset(FridgeMealCards::VT_MEALCARDS, mealcards);
  }
  FridgeMealCardsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FridgeMealCardsBuilder &operator=(const FridgeMealCardsBuilder &);
  flatbuffers::Offset<FridgeMealCards> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<FridgeMealCards>(end);
    return o;
  }
};

inline flatbuffers::Offset<FridgeMealCards> CreateFridgeMealCards(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fridge> fridge = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MealCard>>> mealcards = 0) {
  FridgeMealCardsBuilder builder_(_fbb);
  builder_.add_mealcards(mealcards);
  builder_.add_fridge(fridge);
  return builder_.Finish();
}

inline flatbuffers::Offset<FridgeMealCards> CreateFridgeMealCardsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fridge> fridge = 0,
    const std::vector<flatbuffers::Offset<MealCard>> *mealcards = nullptr) {
  return bs::CreateFridgeMealCards(
      _fbb,
      fridge,
      mealcards ? _fbb.CreateVector<flatbuffers::Offset<MealCard>>(*mealcards) : 0);
}

struct FridgeUser FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRIDGEID = 4,
    VT_USER = 6,
    VT_START = 8,
    VT_FINISH = 10,
    VT_BALANCE = 12
  };
  uint64_t fridgeid() const {
    return GetField<uint64_t>(VT_FRIDGEID, 0);
  }
  const User *user() const {
    return GetPointer<const User *>(VT_USER);
  }
  uint32_t start() const {
    return GetField<uint32_t>(VT_START, 0);
  }
  uint32_t finish() const {
    return GetField<uint32_t>(VT_FINISH, 0);
  }
  int64_t balance() const {
    return GetField<int64_t>(VT_BALANCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FRIDGEID) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyTable(user()) &&
           VerifyField<uint32_t>(verifier, VT_START) &&
           VerifyField<uint32_t>(verifier, VT_FINISH) &&
           VerifyField<int64_t>(verifier, VT_BALANCE) &&
           verifier.EndTable();
  }
};

struct FridgeUserBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fridgeid(uint64_t fridgeid) {
    fbb_.AddElement<uint64_t>(FridgeUser::VT_FRIDGEID, fridgeid, 0);
  }
  void add_user(flatbuffers::Offset<User> user) {
    fbb_.AddOffset(FridgeUser::VT_USER, user);
  }
  void add_start(uint32_t start) {
    fbb_.AddElement<uint32_t>(FridgeUser::VT_START, start, 0);
  }
  void add_finish(uint32_t finish) {
    fbb_.AddElement<uint32_t>(FridgeUser::VT_FINISH, finish, 0);
  }
  void add_balance(int64_t balance) {
    fbb_.AddElement<int64_t>(FridgeUser::VT_BALANCE, balance, 0);
  }
  FridgeUserBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FridgeUserBuilder &operator=(const FridgeUserBuilder &);
  flatbuffers::Offset<FridgeUser> Finish() {
    const auto end = fbb_.EndTable(start_, 5);
    auto o = flatbuffers::Offset<FridgeUser>(end);
    return o;
  }
};

inline flatbuffers::Offset<FridgeUser> CreateFridgeUser(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t fridgeid = 0,
    flatbuffers::Offset<User> user = 0,
    uint32_t start = 0,
    uint32_t finish = 0,
    int64_t balance = 0) {
  FridgeUserBuilder builder_(_fbb);
  builder_.add_balance(balance);
  builder_.add_fridgeid(fridgeid);
  builder_.add_finish(finish);
  builder_.add_start(start);
  builder_.add_user(user);
  return builder_.Finish();
}

struct FridgeUsers FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRIDGE = 4,
    VT_FRIDGEUSERS = 6
  };
  const Fridge *fridge() const {
    return GetPointer<const Fridge *>(VT_FRIDGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FridgeUser>> *fridgeusers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FridgeUser>> *>(VT_FRIDGEUSERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FRIDGE) &&
           verifier.VerifyTable(fridge()) &&
           VerifyOffset(verifier, VT_FRIDGEUSERS) &&
           verifier.Verify(fridgeusers()) &&
           verifier.VerifyVectorOfTables(fridgeusers()) &&
           verifier.EndTable();
  }
};

struct FridgeUsersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fridge(flatbuffers::Offset<Fridge> fridge) {
    fbb_.AddOffset(FridgeUsers::VT_FRIDGE, fridge);
  }
  void add_fridgeusers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FridgeUser>>> fridgeusers) {
    fbb_.AddOffset(FridgeUsers::VT_FRIDGEUSERS, fridgeusers);
  }
  FridgeUsersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FridgeUsersBuilder &operator=(const FridgeUsersBuilder &);
  flatbuffers::Offset<FridgeUsers> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<FridgeUsers>(end);
    return o;
  }
};

inline flatbuffers::Offset<FridgeUsers> CreateFridgeUsers(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fridge> fridge = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FridgeUser>>> fridgeusers = 0) {
  FridgeUsersBuilder builder_(_fbb);
  builder_.add_fridgeusers(fridgeusers);
  builder_.add_fridge(fridge);
  return builder_.Finish();
}

inline flatbuffers::Offset<FridgeUsers> CreateFridgeUsersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fridge> fridge = 0,
    const std::vector<flatbuffers::Offset<FridgeUser>> *fridgeusers = nullptr) {
  return bs::CreateFridgeUsers(
      _fbb,
      fridge,
      fridgeusers ? _fbb.CreateVector<flatbuffers::Offset<FridgeUser>>(*fridgeusers) : 0);
}

struct UserPurchases FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USER = 4,
    VT_PURCHASES = 6
  };
  const User *user() const {
    return GetPointer<const User *>(VT_USER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Purchase>> *purchases() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Purchase>> *>(VT_PURCHASES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyTable(user()) &&
           VerifyOffset(verifier, VT_PURCHASES) &&
           verifier.Verify(purchases()) &&
           verifier.VerifyVectorOfTables(purchases()) &&
           verifier.EndTable();
  }
};

struct UserPurchasesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user(flatbuffers::Offset<User> user) {
    fbb_.AddOffset(UserPurchases::VT_USER, user);
  }
  void add_purchases(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Purchase>>> purchases) {
    fbb_.AddOffset(UserPurchases::VT_PURCHASES, purchases);
  }
  UserPurchasesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserPurchasesBuilder &operator=(const UserPurchasesBuilder &);
  flatbuffers::Offset<UserPurchases> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<UserPurchases>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserPurchases> CreateUserPurchases(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<User> user = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Purchase>>> purchases = 0) {
  UserPurchasesBuilder builder_(_fbb);
  builder_.add_purchases(purchases);
  builder_.add_user(user);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserPurchases> CreateUserPurchasesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<User> user = 0,
    const std::vector<flatbuffers::Offset<Purchase>> *purchases = nullptr) {
  return bs::CreateUserPurchases(
      _fbb,
      user,
      purchases ? _fbb.CreateVector<flatbuffers::Offset<Purchase>>(*purchases) : 0);
}

struct FridgePurchases FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRIDGE = 4,
    VT_USERPURCHASES = 6
  };
  const Fridge *fridge() const {
    return GetPointer<const Fridge *>(VT_FRIDGE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UserPurchases>> *userpurchases() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserPurchases>> *>(VT_USERPURCHASES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FRIDGE) &&
           verifier.VerifyTable(fridge()) &&
           VerifyOffset(verifier, VT_USERPURCHASES) &&
           verifier.Verify(userpurchases()) &&
           verifier.VerifyVectorOfTables(userpurchases()) &&
           verifier.EndTable();
  }
};

struct FridgePurchasesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fridge(flatbuffers::Offset<Fridge> fridge) {
    fbb_.AddOffset(FridgePurchases::VT_FRIDGE, fridge);
  }
  void add_userpurchases(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserPurchases>>> userpurchases) {
    fbb_.AddOffset(FridgePurchases::VT_USERPURCHASES, userpurchases);
  }
  FridgePurchasesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FridgePurchasesBuilder &operator=(const FridgePurchasesBuilder &);
  flatbuffers::Offset<FridgePurchases> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<FridgePurchases>(end);
    return o;
  }
};

inline flatbuffers::Offset<FridgePurchases> CreateFridgePurchases(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fridge> fridge = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserPurchases>>> userpurchases = 0) {
  FridgePurchasesBuilder builder_(_fbb);
  builder_.add_userpurchases(userpurchases);
  builder_.add_fridge(fridge);
  return builder_.Finish();
}

inline flatbuffers::Offset<FridgePurchases> CreateFridgePurchasesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fridge> fridge = 0,
    const std::vector<flatbuffers::Offset<UserPurchases>> *userpurchases = nullptr) {
  return bs::CreateFridgePurchases(
      _fbb,
      fridge,
      userpurchases ? _fbb.CreateVector<flatbuffers::Offset<UserPurchases>>(*userpurchases) : 0);
}

struct UserFridges FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USER = 4,
    VT_MEALCARDS = 6,
    VT_USERS = 8
  };
  const User *user() const {
    return GetPointer<const User *>(VT_USER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FridgeMealCards>> *mealcards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FridgeMealCards>> *>(VT_MEALCARDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FridgeUsers>> *users() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FridgeUsers>> *>(VT_USERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyTable(user()) &&
           VerifyOffset(verifier, VT_MEALCARDS) &&
           verifier.Verify(mealcards()) &&
           verifier.VerifyVectorOfTables(mealcards()) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.Verify(users()) &&
           verifier.VerifyVectorOfTables(users()) &&
           verifier.EndTable();
  }
};

struct UserFridgesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user(flatbuffers::Offset<User> user) {
    fbb_.AddOffset(UserFridges::VT_USER, user);
  }
  void add_mealcards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FridgeMealCards>>> mealcards) {
    fbb_.AddOffset(UserFridges::VT_MEALCARDS, mealcards);
  }
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FridgeUsers>>> users) {
    fbb_.AddOffset(UserFridges::VT_USERS, users);
  }
  UserFridgesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserFridgesBuilder &operator=(const UserFridgesBuilder &);
  flatbuffers::Offset<UserFridges> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<UserFridges>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserFridges> CreateUserFridges(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<User> user = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FridgeMealCards>>> mealcards = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FridgeUsers>>> users = 0) {
  UserFridgesBuilder builder_(_fbb);
  builder_.add_users(users);
  builder_.add_mealcards(mealcards);
  builder_.add_user(user);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserFridges> CreateUserFridgesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<User> user = 0,
    const std::vector<flatbuffers::Offset<FridgeMealCards>> *mealcards = nullptr,
    const std::vector<flatbuffers::Offset<FridgeUsers>> *users = nullptr) {
  return bs::CreateUserFridges(
      _fbb,
      user,
      mealcards ? _fbb.CreateVector<flatbuffers::Offset<FridgeMealCards>>(*mealcards) : 0,
      users ? _fbb.CreateVector<flatbuffers::Offset<FridgeUsers>>(*users) : 0);
}

struct Users FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<User>> *users() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<User>> *>(VT_USERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USERS) &&
           verifier.Verify(users()) &&
           verifier.VerifyVectorOfTables(users()) &&
           verifier.EndTable();
  }
};

struct UsersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<User>>> users) {
    fbb_.AddOffset(Users::VT_USERS, users);
  }
  UsersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UsersBuilder &operator=(const UsersBuilder &);
  flatbuffers::Offset<Users> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Users>(end);
    return o;
  }
};

inline flatbuffers::Offset<Users> CreateUsers(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<User>>> users = 0) {
  UsersBuilder builder_(_fbb);
  builder_.add_users(users);
  return builder_.Finish();
}

inline flatbuffers::Offset<Users> CreateUsersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<User>> *users = nullptr) {
  return bs::CreateUsers(
      _fbb,
      users ? _fbb.CreateVector<flatbuffers::Offset<User>>(*users) : 0);
}

struct Fridges FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRIDGES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fridge>> *fridges() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fridge>> *>(VT_FRIDGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FRIDGES) &&
           verifier.Verify(fridges()) &&
           verifier.VerifyVectorOfTables(fridges()) &&
           verifier.EndTable();
  }
};

struct FridgesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fridges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fridge>>> fridges) {
    fbb_.AddOffset(Fridges::VT_FRIDGES, fridges);
  }
  FridgesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FridgesBuilder &operator=(const FridgesBuilder &);
  flatbuffers::Offset<Fridges> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Fridges>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fridges> CreateFridges(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fridge>>> fridges = 0) {
  FridgesBuilder builder_(_fbb);
  builder_.add_fridges(fridges);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fridges> CreateFridgesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fridge>> *fridges = nullptr) {
  return bs::CreateFridges(
      _fbb,
      fridges ? _fbb.CreateVector<flatbuffers::Offset<Fridge>>(*fridges) : 0);
}

struct Purchases FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PURCHASES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Purchase>> *purchases() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Purchase>> *>(VT_PURCHASES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PURCHASES) &&
           verifier.Verify(purchases()) &&
           verifier.VerifyVectorOfTables(purchases()) &&
           verifier.EndTable();
  }
};

struct PurchasesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_purchases(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Purchase>>> purchases) {
    fbb_.AddOffset(Purchases::VT_PURCHASES, purchases);
  }
  PurchasesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PurchasesBuilder &operator=(const PurchasesBuilder &);
  flatbuffers::Offset<Purchases> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Purchases>(end);
    return o;
  }
};

inline flatbuffers::Offset<Purchases> CreatePurchases(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Purchase>>> purchases = 0) {
  PurchasesBuilder builder_(_fbb);
  builder_.add_purchases(purchases);
  return builder_.Finish();
}

inline flatbuffers::Offset<Purchases> CreatePurchasesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Purchase>> *purchases = nullptr) {
  return bs::CreatePurchases(
      _fbb,
      purchases ? _fbb.CreateVector<flatbuffers::Offset<Purchase>>(*purchases) : 0);
}

struct Meals FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MEALS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Meal>> *meals() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Meal>> *>(VT_MEALS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEALS) &&
           verifier.Verify(meals()) &&
           verifier.VerifyVectorOfTables(meals()) &&
           verifier.EndTable();
  }
};

struct MealsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_meals(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Meal>>> meals) {
    fbb_.AddOffset(Meals::VT_MEALS, meals);
  }
  MealsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MealsBuilder &operator=(const MealsBuilder &);
  flatbuffers::Offset<Meals> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Meals>(end);
    return o;
  }
};

inline flatbuffers::Offset<Meals> CreateMeals(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Meal>>> meals = 0) {
  MealsBuilder builder_(_fbb);
  builder_.add_meals(meals);
  return builder_.Finish();
}

inline flatbuffers::Offset<Meals> CreateMealsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Meal>> *meals = nullptr) {
  return bs::CreateMeals(
      _fbb,
      meals ? _fbb.CreateVector<flatbuffers::Offset<Meal>>(*meals) : 0);
}

struct MealCards FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MEALCARDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<MealCard>> *mealcards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MealCard>> *>(VT_MEALCARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEALCARDS) &&
           verifier.Verify(mealcards()) &&
           verifier.VerifyVectorOfTables(mealcards()) &&
           verifier.EndTable();
  }
};

struct MealCardsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mealcards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MealCard>>> mealcards) {
    fbb_.AddOffset(MealCards::VT_MEALCARDS, mealcards);
  }
  MealCardsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MealCardsBuilder &operator=(const MealCardsBuilder &);
  flatbuffers::Offset<MealCards> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<MealCards>(end);
    return o;
  }
};

inline flatbuffers::Offset<MealCards> CreateMealCards(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MealCard>>> mealcards = 0) {
  MealCardsBuilder builder_(_fbb);
  builder_.add_mealcards(mealcards);
  return builder_.Finish();
}

inline flatbuffers::Offset<MealCards> CreateMealCardsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MealCard>> *mealcards = nullptr) {
  return bs::CreateMealCards(
      _fbb,
      mealcards ? _fbb.CreateVector<flatbuffers::Offset<MealCard>>(*mealcards) : 0);
}

struct Payment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRIDGEID = 4,
    VT_USERID = 6,
    VT_START = 8,
    VT_TOTAL = 10
  };
  uint64_t fridgeid() const {
    return GetField<uint64_t>(VT_FRIDGEID, 0);
  }
  uint64_t userid() const {
    return GetField<uint64_t>(VT_USERID, 0);
  }
  uint32_t start() const {
    return GetField<uint32_t>(VT_START, 0);
  }
  int32_t total() const {
    return GetField<int32_t>(VT_TOTAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_FRIDGEID) &&
           VerifyField<uint64_t>(verifier, VT_USERID) &&
           VerifyField<uint32_t>(verifier, VT_START) &&
           VerifyField<int32_t>(verifier, VT_TOTAL) &&
           verifier.EndTable();
  }
};

struct PaymentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fridgeid(uint64_t fridgeid) {
    fbb_.AddElement<uint64_t>(Payment::VT_FRIDGEID, fridgeid, 0);
  }
  void add_userid(uint64_t userid) {
    fbb_.AddElement<uint64_t>(Payment::VT_USERID, userid, 0);
  }
  void add_start(uint32_t start) {
    fbb_.AddElement<uint32_t>(Payment::VT_START, start, 0);
  }
  void add_total(int32_t total) {
    fbb_.AddElement<int32_t>(Payment::VT_TOTAL, total, 0);
  }
  PaymentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PaymentBuilder &operator=(const PaymentBuilder &);
  flatbuffers::Offset<Payment> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Payment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Payment> CreatePayment(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t fridgeid = 0,
    uint64_t userid = 0,
    uint32_t start = 0,
    int32_t total = 0) {
  PaymentBuilder builder_(_fbb);
  builder_.add_userid(userid);
  builder_.add_fridgeid(fridgeid);
  builder_.add_total(total);
  builder_.add_start(start);
  return builder_.Finish();
}

struct Payments FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PAYMENTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Payment>> *payments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Payment>> *>(VT_PAYMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PAYMENTS) &&
           verifier.Verify(payments()) &&
           verifier.VerifyVectorOfTables(payments()) &&
           verifier.EndTable();
  }
};

struct PaymentsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_payments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Payment>>> payments) {
    fbb_.AddOffset(Payments::VT_PAYMENTS, payments);
  }
  PaymentsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PaymentsBuilder &operator=(const PaymentsBuilder &);
  flatbuffers::Offset<Payments> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Payments>(end);
    return o;
  }
};

inline flatbuffers::Offset<Payments> CreatePayments(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Payment>>> payments = 0) {
  PaymentsBuilder builder_(_fbb);
  builder_.add_payments(payments);
  return builder_.Finish();
}

inline flatbuffers::Offset<Payments> CreatePaymentsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Payment>> *payments = nullptr) {
  return bs::CreatePayments(
      _fbb,
      payments ? _fbb.CreateVector<flatbuffers::Offset<Payment>>(*payments) : 0);
}

}  // namespace bs

#endif  // FLATBUFFERS_GENERATED_BUYNSHARE_BS_H_
